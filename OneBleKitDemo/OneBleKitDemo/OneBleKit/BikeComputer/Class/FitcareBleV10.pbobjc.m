// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fitcare_ble_V1.0.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "FitcareBleV10.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - FitcareBleV10Root

@implementation FitcareBleV10Root

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - FitcareBleV10Root_FileDescriptor

static GPBFileDescriptor *FitcareBleV10Root_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum DevType

GPBEnumDescriptor *DevType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DevTypeHandwatch\000DevTypeHub\000DevTypeBikeC"
        "omputer\000";
    static const int32_t values[] = {
        DevType_DevTypeHandwatch,
        DevType_DevTypeHub,
        DevType_DevTypeBikeComputer,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DevType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DevType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DevType_IsValidValue(int32_t value__) {
  switch (value__) {
    case DevType_DevTypeHandwatch:
    case DevType_DevTypeHub:
    case DevType_DevTypeBikeComputer:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FileTransSize

GPBEnumDescriptor *FileTransSize_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "FileTransSize128\000FileTransSize256\000FileTr"
        "ansSize512\000FileTransSize1024\000";
    static const int32_t values[] = {
        FileTransSize_FileTransSize128,
        FileTransSize_FileTransSize256,
        FileTransSize_FileTransSize512,
        FileTransSize_FileTransSize1024,
    };
    static const char *extraTextFormatInfo = "\004\000d\345\344\203\000\001d\345\344\203\000\002d\345\344\203\000\003d\345\344\204\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FileTransSize)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FileTransSize_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FileTransSize_IsValidValue(int32_t value__) {
  switch (value__) {
    case FileTransSize_FileTransSize128:
    case FileTransSize_FileTransSize256:
    case FileTransSize_FileTransSize512:
    case FileTransSize_FileTransSize1024:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FileTransStatus

GPBEnumDescriptor *FileTransStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "FileTransStatusIdle\000FileTransStatusTrans"
        "\000";
    static const int32_t values[] = {
        FileTransStatus_FileTransStatusIdle,
        FileTransStatus_FileTransStatusTrans,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FileTransStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FileTransStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FileTransStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case FileTransStatus_FileTransStatusIdle:
    case FileTransStatus_FileTransStatusTrans:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DeviceInfo

@implementation DeviceInfo

@dynamic devType;
@dynamic fileTransSize;
@dynamic hardwareVersion;
@dynamic softwareVersion;
@dynamic serialNumber;
@dynamic protocolVersion;

typedef struct DeviceInfo__storage_ {
  uint32_t _has_storage_[1];
  DevType devType;
  FileTransSize fileTransSize;
  NSString *hardwareVersion;
  NSString *softwareVersion;
  NSString *serialNumber;
  NSString *protocolVersion;
} DeviceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "devType",
        .dataTypeSpecific.enumDescFunc = DevType_EnumDescriptor,
        .number = DeviceInfo_FieldNumber_DevType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, devType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fileTransSize",
        .dataTypeSpecific.enumDescFunc = FileTransSize_EnumDescriptor,
        .number = DeviceInfo_FieldNumber_FileTransSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, fileTransSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "hardwareVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_HardwareVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, hardwareVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "softwareVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_SoftwareVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, softwareVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serialNumber",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_SerialNumber,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, serialNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "protocolVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = DeviceInfo_FieldNumber_ProtocolVersion,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, protocolVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceInfo class]
                                     rootClass:[FitcareBleV10Root class]
                                          file:FitcareBleV10Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DeviceInfo_DevType_RawValue(DeviceInfo *message) {
  GPBDescriptor *descriptor = [DeviceInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DeviceInfo_FieldNumber_DevType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDeviceInfo_DevType_RawValue(DeviceInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [DeviceInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DeviceInfo_FieldNumber_DevType];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t DeviceInfo_FileTransSize_RawValue(DeviceInfo *message) {
  GPBDescriptor *descriptor = [DeviceInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DeviceInfo_FieldNumber_FileTransSize];
  return GPBGetMessageRawEnumField(message, field);
}

void SetDeviceInfo_FileTransSize_RawValue(DeviceInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [DeviceInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DeviceInfo_FieldNumber_FileTransSize];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - UtcInfo

@implementation UtcInfo

@dynamic utc;
@dynamic tiemZone;

typedef struct UtcInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t utc;
  float tiemZone;
} UtcInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "utc",
        .dataTypeSpecific.clazz = Nil,
        .number = UtcInfo_FieldNumber_Utc,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UtcInfo__storage_, utc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "tiemZone",
        .dataTypeSpecific.clazz = Nil,
        .number = UtcInfo_FieldNumber_TiemZone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UtcInfo__storage_, tiemZone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UtcInfo class]
                                     rootClass:[FitcareBleV10Root class]
                                          file:FitcareBleV10Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UtcInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HistoryGetRsp

@implementation HistoryGetRsp

@dynamic isExist;

typedef struct HistoryGetRsp__storage_ {
  uint32_t _has_storage_[1];
} HistoryGetRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isExist",
        .dataTypeSpecific.clazz = Nil,
        .number = HistoryGetRsp_FieldNumber_IsExist,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HistoryGetRsp class]
                                     rootClass:[FitcareBleV10Root class]
                                          file:FitcareBleV10Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HistoryGetRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FileGetReq

@implementation FileGetReq

@dynamic fileName;

typedef struct FileGetReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *fileName;
} FileGetReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileName",
        .dataTypeSpecific.clazz = Nil,
        .number = FileGetReq_FieldNumber_FileName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FileGetReq__storage_, fileName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FileGetReq class]
                                     rootClass:[FitcareBleV10Root class]
                                          file:FitcareBleV10Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FileGetReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FileGetRsp

@implementation FileGetRsp

@dynamic isExist;

typedef struct FileGetRsp__storage_ {
  uint32_t _has_storage_[1];
} FileGetRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isExist",
        .dataTypeSpecific.clazz = Nil,
        .number = FileGetRsp_FieldNumber_IsExist,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FileGetRsp class]
                                     rootClass:[FitcareBleV10Root class]
                                          file:FitcareBleV10Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FileGetRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FileDeleteReq

@implementation FileDeleteReq

@dynamic fileName;

typedef struct FileDeleteReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *fileName;
} FileDeleteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileName",
        .dataTypeSpecific.clazz = Nil,
        .number = FileDeleteReq_FieldNumber_FileName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FileDeleteReq__storage_, fileName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FileDeleteReq class]
                                     rootClass:[FitcareBleV10Root class]
                                          file:FitcareBleV10Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FileDeleteReq__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FileInfo

@implementation FileInfo

@dynamic fileName;
@dynamic fileSize;

typedef struct FileInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t fileSize;
  NSString *fileName;
} FileInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileName",
        .dataTypeSpecific.clazz = Nil,
        .number = FileInfo_FieldNumber_FileName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FileInfo__storage_, fileName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.clazz = Nil,
        .number = FileInfo_FieldNumber_FileSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FileInfo__storage_, fileSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FileInfo class]
                                     rootClass:[FitcareBleV10Root class]
                                          file:FitcareBleV10Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FileInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FileTransStatusGetRsp

@implementation FileTransStatusGetRsp

@dynamic fileTransStatus;

typedef struct FileTransStatusGetRsp__storage_ {
  uint32_t _has_storage_[1];
  FileTransStatus fileTransStatus;
} FileTransStatusGetRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileTransStatus",
        .dataTypeSpecific.enumDescFunc = FileTransStatus_EnumDescriptor,
        .number = FileTransStatusGetRsp_FieldNumber_FileTransStatus,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FileTransStatusGetRsp__storage_, fileTransStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FileTransStatusGetRsp class]
                                     rootClass:[FitcareBleV10Root class]
                                          file:FitcareBleV10Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FileTransStatusGetRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t FileTransStatusGetRsp_FileTransStatus_RawValue(FileTransStatusGetRsp *message) {
  GPBDescriptor *descriptor = [FileTransStatusGetRsp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FileTransStatusGetRsp_FieldNumber_FileTransStatus];
  return GPBGetMessageRawEnumField(message, field);
}

void SetFileTransStatusGetRsp_FileTransStatus_RawValue(FileTransStatusGetRsp *message, int32_t value) {
  GPBDescriptor *descriptor = [FileTransStatusGetRsp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FileTransStatusGetRsp_FieldNumber_FileTransStatus];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - StorageGetRsp

@implementation StorageGetRsp

@dynamic remainSize;
@dynamic totalSize;

typedef struct StorageGetRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t remainSize;
  int32_t totalSize;
} StorageGetRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "remainSize",
        .dataTypeSpecific.clazz = Nil,
        .number = StorageGetRsp_FieldNumber_RemainSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StorageGetRsp__storage_, remainSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "totalSize",
        .dataTypeSpecific.clazz = Nil,
        .number = StorageGetRsp_FieldNumber_TotalSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StorageGetRsp__storage_, totalSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StorageGetRsp class]
                                     rootClass:[FitcareBleV10Root class]
                                          file:FitcareBleV10Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StorageGetRsp__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
